
import { supabase } from '@/lib/supabase';
import { dataService } from './dataService';

export interface QueryResult {
  data: any[];
  chartType: 'bar' | 'line' | 'pie' | 'scatter' | 'table';
  chartConfig: any;
  sql?: string;
  explanation?: string;
}

export const nlpService = {
  // Process a natural language query
  async processQuery(query: string, datasetId: string): Promise<QueryResult> {
    try {
      // Get dataset information
      const dataset = await dataService.getDataset(datasetId);
      if (!dataset) {
        throw new Error('Dataset not found');
      }
      
      // For MVP, we'll simulate an NLP interpretation
      // In a real app, this would call an LLM API like OpenAI
      const processedResult = await this._simulateNlpProcessing(query, dataset);
      return processedResult;
    } catch (error) {
      console.error('Error processing NL query:', error);
      throw error;
    }
  },

  // Simulate NLP processing (this would be replaced with actual LLM call)
  async _simulateNlpProcessing(query: string, dataset: any): Promise<QueryResult> {
    try {
      // Preview some data to work with
      const previewData = await dataService.previewDataset(dataset.id, 1000);
      
      // Very basic keyword matching for demo purposes
      const lowerQuery = query.toLowerCase();
      
      // Determine chart type based on keywords
      let chartType: 'bar' | 'line' | 'pie' | 'scatter' | 'table' = 'table';
      
      if (lowerQuery.includes('over time') || lowerQuery.includes('trend') || 
          lowerQuery.includes('by month') || lowerQuery.includes('by year')) {
        chartType = 'line';
      } else if (lowerQuery.includes('compare') || lowerQuery.includes('comparison') ||
                lowerQuery.includes('difference') || lowerQuery.includes('versus')) {
        chartType = 'bar';
      } else if (lowerQuery.includes('distribution') || lowerQuery.includes('percentage') ||
                lowerQuery.includes('proportion') || lowerQuery.includes('share')) {
        chartType = 'pie';
      } else if (lowerQuery.includes('correlation') || lowerQuery.includes('relationship') ||
                lowerQuery.includes('scatter') || lowerQuery.includes('between')) {
        chartType = 'scatter';
      }
      
      // Very simple aggregation based on columns in the dataset
      // In a real app, this would be generated by the LLM
      const schemaKeys = Object.keys(dataset.column_schema);
      
      let xAxis = '';
      let yAxis = '';
      
      // Find potential date columns for time series
      for (const key of schemaKeys) {
        if (dataset.column_schema[key] === 'date' || 
            key.toLowerCase().includes('date') || 
            key.toLowerCase().includes('month') ||
            key.toLowerCase().includes('year')) {
          xAxis = key;
          break;
        }
      }
      
      // Find potential numeric columns for values
      for (const key of schemaKeys) {
        if (dataset.column_schema[key] === 'number' || 
            dataset.column_schema[key] === 'integer' ||
            key.toLowerCase().includes('sales') ||
            key.toLowerCase().includes('revenue') ||
            key.toLowerCase().includes('amount') ||
            key.toLowerCase().includes('price')) {
          yAxis = key;
          break;
        }
      }
      
      // If we couldn't determine axes, use the first two columns
      if (!xAxis && schemaKeys.length > 0) xAxis = schemaKeys[0];
      if (!yAxis && schemaKeys.length > 1) yAxis = schemaKeys[1];
      
      // Generate a simple mock result
      // In a real app, this would be the result of executing a query
      let resultData: any[] = [];
      
      if (chartType === 'bar' || chartType === 'line') {
        // Group by x-axis and sum y-axis
        const groupedData = this._groupAndAggregate(previewData, xAxis, yAxis);
        resultData = groupedData;
      } else if (chartType === 'pie') {
        // Group by x-axis and sum y-axis (same logic, different visualization)
        const groupedData = this._groupAndAggregate(previewData, xAxis, yAxis);
        resultData = groupedData;
      } else if (chartType === 'scatter') {
        // Just use raw data points
        resultData = previewData.slice(0, 50).map(row => ({
          x: row[xAxis],
          y: row[yAxis]
        }));
      } else {
        // Table view - just return the raw data
        resultData = previewData.slice(0, 100);
      }
      
      return {
        data: resultData,
        chartType,
        chartConfig: {
          xAxis: xAxis,
          yAxis: yAxis,
          title: query,
        },
        explanation: `I analyzed your question "${query}" and determined that you're likely interested in the ${chartType === 'line' ? 'trend of' : chartType === 'pie' ? 'distribution of' : 'relationship between'} ${xAxis} and ${yAxis}.`
      };
    } catch (error) {
      console.error('Error in simulated NLP processing:', error);
      throw error;
    }
  },

  // Helper function to group and aggregate data
  _groupAndAggregate(data: any[], groupByColumn: string, valueColumn: string): any[] {
    const grouped: Record<string, number> = {};
    
    data.forEach(row => {
      const key = row[groupByColumn];
      const value = parseFloat(row[valueColumn]) || 0;
      
      if (!grouped[key]) {
        grouped[key] = 0;
      }
      
      grouped[key] += value;
    });
    
    return Object.entries(grouped).map(([key, value]) => ({
      [groupByColumn]: key,
      [valueColumn]: value
    }));
  }
};
